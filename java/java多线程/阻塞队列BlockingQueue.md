阻塞队(BlockingQueue)是util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式。当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满。从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。 
无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。
## 阻塞队列和非阻塞队列的区别
阻塞队列与非阻塞队列一个最大的区别就是：阻塞队列能够阻塞当前试图从队列中获取元素的线程，而非阻塞队列不会。因此在面对类似消费者-生产者的模型时，使用非阻塞队列就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。但是有了阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。  
##  常见的阻塞队列
阻塞队列由BlockingQueue定义，阻塞队列需要实现该接口
* ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小，并且可以指定公平性和非公平性。默认是非公平性。即不保证等待时间最长的线程最优先能够访问队列。
* LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象如果不指定容量大小，则默认大小为Integer.MAX_VALUE。
* PriorityBlockingQueue：无界阻塞队列，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。
* DelayQueue：基于PriorityQueue实现的延迟队列，是一个无界阻塞队列，用于放置实现了Delayed接口对象，其中的对象只能在其到时才能从队列中取走。因此向队列中插入时永远不会阻塞。获取时才有可能被阻塞。
* SynchronouseQueue：同步阻塞队列，队列大小为1，一个元素要放到该队列中必须有一个线程等待获取元素。
* DelayWorkQueue：队列为ScheduledThreadPoolExecutor中的静态内部类，ScheduledThreadPoolExecutor便是通过该队列使得队列中的元素按一定顺序排列从而时延迟任务和周期性任务得以顺利执行。 
* BlockingQueue:双向阻塞队列的接口。
* TransferQueue：接口，定义了另一种阻塞情况：生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费，而BlockingQueue只需将元素添加到队列中后生产者便会停止被阻塞。

### 阻塞队列常用方法
非阻塞队列
* add(e)：将元素e插入到队列末尾，如果插入成功则返回true。
* remove()：移除队首元素，如果移除成功则返回ture。
* offer(e)：将元素插入到队列末尾
* poll（）：移除并获取队首元素。
* peek()：获取队首元素，但不移除。 
阻塞队列
* put()：向队尾存入元素，如果队列为空，则等待。
* take():从队首取元素，如果队列为空，则等待。
* offer(e,timeout,timeUnit)：向队尾存入元素，如果队列满，则等待一定时间，当时间基限到达时，如果还没有插入成功则返回false。
* poll(timeout,timeUnit)：从队首取元素，如果队列空，则等待一定时间，如果时间到达时还没有取则返回null。

阻塞队列最常使用在生产者消费者模式，也是各种实现生产者消费者首选的方式。不需要关心什么阻塞生产，什么时候阻塞消费。使用方便。
### 阻塞队列原理
其实阻塞队列实现阻塞同步的方式很简单，使用的就是是lock锁的多条件（condition）阻塞控制。使用BlockingQueue封装了根据条件阻塞线程的过程，而我们就不用关心繁琐的await/signal操作了。